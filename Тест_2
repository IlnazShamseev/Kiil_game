import math
import os

import pygame
import pytmx

pygame.init()

game = True
SCREEN_MAIN = pygame.display.set_mode((0, 0), pygame.FULLSCREEN)

width, height = SCREEN_MAIN.get_size()

FPS = 60
clock = pygame.time.Clock()


def way(files):
    fullname = os.path.join("data", *files)
    if not os.path.isfile(fullname):
        print(f"Файл '{fullname}' не найден")
        import sys
        sys.exit()
    return fullname


def mouse_get_pos():
    x, y = pygame.mouse.get_pos()
    w, h = MANUAL_CURSOR.get_size()
    return x - w // 2, y - h // 2


def load_image(files, size=None, colorkey=None):
    fullname = way(files)
    image = pygame.image.load(fullname)

    if colorkey is not None:
        if colorkey == -1:
            colorkey = image.get_at((0, 0))
        image.set_colorkey(colorkey)
    else:
        image = image.convert_alpha()

    if size is not None:
        image = pygame.transform.scale(image, size)

    return image


class Dino(pygame.sprite.Sprite):
    image = [
        load_image(("hero", "DINO.png",), (32, 32), -1),
        pygame.transform.flip(load_image(("hero", "DINO.png",), (32, 32), -1), True, False)
    ]

    def __init__(self, x, y):
        super().__init__()
        self.image = Dino.image[0]
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.v = 180

        self.duration = "s"
        self.step = 0

    def update(self, *args):
        a_key = args[0][ord("a")]
        d_key = args[0][ord("d")]

        if a_key and not d_key:
            self.image = Dino.image[1]
        if d_key and not a_key:
            self.image = Dino.image[0]


class Hero(pygame.sprite.Sprite):
    images = {
        "w": (
            load_image(("hero", "heroes_w0.png")),
            load_image(("hero", "heroes_w1.png")),
            load_image(("hero", "heroes_w2.png"))
        ),
        "a": (
            load_image(("hero", "heroes_a0.png")),
            load_image(("hero", "heroes_a1.png")),
            load_image(("hero", "heroes_a2.png"))
        ),
        "s": (
            load_image(("hero", "heroes_s0.png")),
            load_image(("hero", "heroes_s1.png")),
            load_image(("hero", "heroes_s2.png"))
        ),
        "d": (
            load_image(("hero", "heroes_d0.png")),
            load_image(("hero", "heroes_d1.png")),
            load_image(("hero", "heroes_d2.png"))
        ),
    }

    def __init__(self):
        super().__init__()
        self.image = Hero.images["s"][0]
        self.rect = self.image.get_rect()
        self.rect.x = (width - self.rect.x) // 2
        self.rect.y = (height - self.rect.y) // 2
        self.FPS = 30

        self.v = 180
        self.duration = "s"
        self.step = 0

    def update(self, keyboard, mouse):
        # print(self.rect.x, self.rect.y)

        w_key = keyboard[ord("w")]
        a_key = keyboard[ord("a")]
        s_key = keyboard[ord("s")]
        d_key = keyboard[ord("d")]

        if w_key ^ s_key or a_key ^ d_key:
            self.step = (self.step + 1) % self.FPS
            self.image = Hero.images[self.duration][self.step // (self.FPS // 2) + 1]

        if s_key and not w_key:
            if self.duration != "s":
                self.step = 0
                self.duration = "s"
        elif w_key and not s_key:
            if self.duration != "w":
                self.step = 0
                self.duration = "w"
        elif d_key and not a_key:
            if self.duration != "d":
                self.step = 0
                self.duration = "d"
        elif a_key and not d_key:
            if self.duration != "a":
                self.step = 0
                self.duration = "a"
        else:
            self.image = Hero.images[self.duration][0]
            self.step = 0


class Game:
    def __init__(self):
        self.map = pytmx.load_pygame(way(("maps", "map.tmx")))

        self.height = self.map.height
        self.width = self.map.width
        self.tile_size = self.map.tilewidth

        self.screen = pygame.Surface(size=(self.width * self.tile_size, self.height * self.tile_size))
        self.walls = [[0] * width for i in range(self.height)]

        self.creature_map(self.screen)

        self.hero = Hero()
        self.bullets = []
        self.dinos = []
        self.create_dino(0, 0)

        self.left = 500
        self.top = 500

    def creature_map(self, screen):
        for k in range(7):
            for y in range(self.height):
                for x in range(self.width):
                    image = self.map.get_tile_image(x, y, k)
                    if image is not None:
                        if k:
                            self.walls[y][x] = 1
                        pygame.transform.scale(image,
                                               (self.tile_size, self.tile_size)
                                               )
                        screen.blit(image, (x * self.tile_size, y * self.tile_size))

        print(*self.walls, sep="\n")

    def render(self, screen):
        screen.blit(self.screen, (0, 0), (self.left, self.top, width, height))
        screen.blit(self.hero.image, self.hero.rect)

        for dino in self.dinos:
            screen.blit(dino.image,
                        (dino.rect.x - self.left, dino.rect.y - self.top, dino.rect.width, dino.rect.height))

        for bullet in self.bullets:
            x_pos, y_pos, _, _ = bullet
            if self.left <= x_pos <= self.left + width:
                pygame.draw.circle(
                    screen, "red", (x_pos - self.left, y_pos - self.top), 5
                )

    def create_dino(self, x, y):
        self.dinos.append(
            Dino(x, y)
        )

    def move_hero(self, keyboard):
        w_key = keyboard[ord("w")]
        a_key = keyboard[ord("a")]
        s_key = keyboard[ord("s")]
        d_key = keyboard[ord("d")]

        if not (w_key ^ s_key or a_key ^ d_key):
            return

        pix = self.hero.v // FPS

        vec_width = 0
        vec_height = 0

        # 1
        if s_key and not w_key:
            if d_key and not a_key:
                pix = pix // (2 ** 0.5)
                vec_width += pix
            elif a_key and not d_key:
                pix = pix // (2 ** 0.5)
                vec_width -= pix
            vec_height += pix
        elif w_key and not s_key:
            if d_key and not a_key:
                pix = pix // (2 ** 0.5)
                vec_width += pix
            elif a_key and not d_key:
                pix = pix // (2 ** 0.5)
                vec_width -= pix
            vec_height -= pix
        elif d_key and not a_key:
            vec_width += pix
        elif a_key and not d_key:
            vec_width -= pix

        # 2
        if vec_width < 0:
            pos_x = int((self.left + width // 2) // self.tile_size)
            pos_y1 = int((self.top + height // 2) // self.tile_size)
            pos_y2 = int(math.ceil((self.top + height // 2 + self.hero.rect.height) / self.tile_size))

            for i in range(pos_y2 - pos_y1):
                if self.walls[pos_y1 + i][pos_x]:
                    break
            else:
                self.left += vec_width
        elif vec_width > 0:
            pos_x = int((self.left + width // 2 + self.hero.rect.width) // self.tile_size)
            pos_y1 = int((self.top + height // 2) // self.tile_size)
            pos_y2 = int(math.ceil((self.top + height // 2 + self.hero.rect.height) / self.tile_size))

            for i in range(pos_y2 - pos_y1):
                if self.walls[pos_y1 + i][pos_x]:
                    break
            else:
                self.left += vec_width

        if vec_height < 0:
            pos_y = int((self.top + height // 2) // self.tile_size)
            pos_x1 = int((self.left + width // 2) // self.tile_size)
            pos_x2 = int((self.left + width // 2 + self.hero.rect.width) // self.tile_size)

            for i in range(pos_x2 - pos_x1):
                if self.walls[pos_y][pos_x1 + i]:
                    break
            else:
                self.top += vec_height
        elif vec_height > 0:
            pos_y = int((self.top + height // 2 + self.hero.rect.height) // self.tile_size)
            pos_x1 = int((self.left + width // 2) // self.tile_size)
            pos_x2 = int((self.left + width // 2 + self.hero.rect.width) // self.tile_size)

            for i in range(pos_x2 - pos_x1):
                if self.walls[pos_y][pos_x1 + i]:
                    break
            else:
                self.top += vec_height

        self.left = min(max(self.left, -width // 2), self.tile_size * self.width - width // 2 - self.hero.rect.width)
        self.top = min(max(self.top, -height // 2), self.tile_size * self.height - height // 2 - self.hero.rect.height)

    def create_bullet(self, mouse):
        button_left, button_center, button_right = mouse.get_pressed()

        if not button_left:
            return

        x, y = mouse_get_pos()

        pos = self.left + width // 2 + self.hero.rect.width // 2, self.top + height // 2 + self.hero.rect.height // 2

        v = 5
        x_vec = (x - (width // 2 + self.hero.rect.width // 2))
        y_vec = (y - (height // 2 + self.hero.rect.height // 2))

        k = (v ** 2 / ((x_vec ** 2 + y_vec ** 2) / (FPS ** 2))) ** 0.5

        self.bullets.append(
            (pos[0], pos[1], x_vec * k, y_vec * k)
        )

    def move_dinos(self):
        for dino in self.dinos:
            v = 0.25
            x = int(self.left + self.hero.rect.x - dino.rect.x)
            y = int(self.top + self.hero.rect.y - dino.rect.y)

            k = (v ** 2 / (((self.left + self.width // 2 - dino.rect.x) ** 2 + (
                    self.left + self.height // 2 - dino.rect.y) ** 2) / (FPS ** 2))) ** 0.5

            dino.rect.x += x * k
            dino.rect.y += y * k

    def shot(self):
        bullets = []

        for bullet in self.bullets:
            x_pos, y_pos, x_vec, y_vec = bullet
            x_pos += x_vec / FPS
            y_pos += y_vec / FPS

            dinos = []
            f = True
            for dino in self.dinos:
                if dino.rect.x <= x_pos <= dino.rect.x + dino.rect.width:
                    if dino.rect.y <= y_pos <= dino.rect.y + dino.rect.height:
                        if f:
                            f = False
                            continue
                dinos.append(dino)
            self.dinos = dinos

            if f:
                if 0 <= x_pos <= self.tile_size * self.width:
                    if 0 <= y_pos <= self.tile_size * self.height:
                        bullets.append(
                            (x_pos, y_pos, x_vec, y_vec)
                        )

        self.bullets = bullets

    def update(self, keyboard, mouse):
        self.hero.update(keyboard, mouse)
        self.move_hero(keyboard)
        self.move_dinos()
        self.shot()


pygame.mouse.set_visible(False)
MANUAL_CURSOR = load_image(("crosshair.png",), (30, 30), -1)

GAME = Game()

while game:

    shot = False

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            game = False
        if event.type == pygame.MOUSEBUTTONDOWN:
            GAME.create_bullet(pygame.mouse)

    SCREEN_MAIN.fill("black")

    GAME.render(SCREEN_MAIN)
    GAME.update(pygame.key.get_pressed(), pygame.mouse)

    mouse_pos = pygame.mouse.get_pos()
    mouse_size = MANUAL_CURSOR.get_size()

    SCREEN_MAIN.blit(MANUAL_CURSOR, (mouse_pos[0] - mouse_size[0], mouse_pos[1] - mouse_size[1]))

    clock.tick(FPS)
    pygame.display.flip()

pygame.quit()
